<div dir="rtl">

#  دیزاین پترن ها در پایتون 

## الگوهای آفرینشی (Creational Pattern)

- [الگوی کارخانه (Factory Method Pattern)](#الگوی-کارخانه-factory-method-pattern)
- [الگوی کارخانه انتزاعی (Abstract Factory Pattern)](#الگوی-کارخانه-انتزاعی-abstract-factory-pattern)
- [الگوی سازنده (Builder Pattern)](#الگوی-سازنده-builder-pattern)
- [الگوی تک‌نمونه (Singleton Pattern)](#الگوی-تک‌نمونه-singleton-pattern)
- [الگوی نمونه‌برداری (Prototype Pattern)](#الگوی-نمونه‌برداری-prototype-pattern)

## الگوهای ساختاری (Structural Pattern)

- [الگوی آداپتور (Adapter Pattern)](#الگوی-آداپتور-adapter-pattern)
- [الگوی پل (Bridge Pattern)](#الگوی-پل-bridge-pattern)
- [الگوی ترکیب (Composite Pattern)](#الگوی-ترکیب-composite-pattern)
- [الگوی دکوراتور (Decorator Pattern)](#الگوی-دکوراتور-decorator-pattern)
- [الگوی فاساد (Facade Pattern)](#الگوی-فاساد-facade-pattern)
- [الگوی فلای‌ویت (Flyweight Pattern)](#الگوی-فلای‌ویت-flyweight-pattern)
- [الگوی پروکسی (Proxy Pattern)](#الگوی-پروکسی-proxy-pattern)

## الگوهای رفتاری (Behavioral Pattern)

- [الگوی زنجیره مسئولیت (Chain of Responsibility Pattern)](#الگوی-زنجیره-مسئولیت-chain-of-responsibility-pattern)
- [الگوی فرمان (Command Pattern)](#الگوی-فرمان-command-pattern)
- [الگوی مفسر (Interpreter Pattern)](#الگوی-مفسر-interpreter-pattern)
- [الگوی تکرارگر (Iterator Pattern)](#الگوی-تکرارگر-iterator-pattern)
- [الگوی میانجی (Mediator Pattern)](#الگوی-میانجی-mediator-pattern)
- [الگوی یادگاری (Memento Pattern)](#الگوی-یادگاری-memento-pattern)
- [الگوی ناظر (Observer Pattern)](#الگوی-ناظر-observer-pattern)
- [الگوی وضعیت (State Pattern)](#الگوی-وضعیت-state-pattern)
- [الگوی استراتژی (Strategy Pattern)](#الگوی-استراتژی-strategy-pattern)
- [الگوی روش قالب (Template Method Pattern)](#الگوی-روش-قالب-template-method-pattern)
- [الگوی بازدیدکننده (Visitor Pattern)](#الگوی-بازدیدکننده-visitor-pattern)

---

##  الگوهای آفرینشی (Creational Pattern) 

### الگوی کارخانه (Factory Method Pattern)

الگوی **کارخانه** به شما اجازه می‌دهد تا ایجاد اشیاء را به زیرکلاس‌ها واگذار کنید، به طوری که کلاس پایه تصمیم نگیرد کدام شیء ایجاد شود. این الگو ایجاد اشیاء را کپسوله می‌کند و وابستگی به کلاس‌های مشخص را کاهش می‌دهد.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که کلاس پایه نمی‌تواند یا نباید تصمیم بگیرد که کدام زیرکلاس باید ایجاد شود.
+ برای جداسازی کد ایجاد شیء از کد استفاده از آن.
+ ایجاد اشیاء در زمان اجرا وابسته به ورودی یا تنظیمات.

#### نکات مثبت این دیزاین پترن:

+ **افزایش انعطاف‌پذیری** در افزودن یا تغییر کلاس‌های محصول.
+ **کاهش اتصال بین کلاس‌ها** و وابستگی به پیاده‌سازی‌های مشخص.
+ **تسهیل در نگهداری و توسعه** برنامه.

#### نکات منفی این دیزاین پترن:

+ **افزایش پیچیدگی کد** با افزودن کلاس‌های اضافی.
+ ممکن است برای **کاربردهای ساده بیش از حد** باشد.

---

### الگوی کارخانه انتزاعی (Abstract Factory Pattern)

الگوی **کارخانه انتزاعی** رابطی برای ایجاد خانواده‌ای از اشیاء مرتبط یا وابسته بدون مشخص کردن کلاس‌های دقیق فراهم می‌کند. این الگو به شما اجازه می‌دهد تا گروهی از محصولات مرتبط را به صورت یکجا مدیریت کنید.

#### موارد استفاده از این دیزاین پترن:

+ ساخت سیستم‌هایی که می‌توانند با **خانواده‌های مختلفی از اشیاء** کار کنند.
+ زمانی که نیاز به ایجاد اشیاء بدون مشخص کردن کلاس‌های دقیق آن‌ها دارید.
+ وقتی که سیستم باید **مستقل از نحوه ایجاد و ترکیب اشیاء** باشد.

#### نکات مثبت این دیزاین پترن:

+ **جداسازی کد ایجاد از کد استفاده**، افزایش ماژولاریتی.
+ تسهیل در **افزودن خانواده‌های جدید محصولات** بدون تغییر کدهای موجود.
+ **تضمین سازگاری** بین اشیاء ایجاد شده در یک خانواده.

#### نکات منفی این دیزاین پترن:

+ **افزودن پیچیدگی بیشتر** با ایجاد کلاس‌های کارخانه اضافی.
+ دشواری در **افزودن محصولات جدید** به خانواده‌های موجود.

---

### الگوی سازنده (Builder Pattern)

الگوی **سازنده** فرآیند ساخت اشیاء پیچیده را با جداسازی ساخت از نمایش کپسوله می‌کند، به طوری که همان فرآیند ساخت می‌تواند نمایش‌های متفاوتی را تولید کند.

#### موارد استفاده از این دیزاین پترن:

+ ساخت اشیائی که دارای **تعداد زیادی پارامتر یا تنظیمات** هستند.
+ زمانی که می‌خواهید ساخت اشیاء در **مراحل جداگانه** انجام شود.
+ ایجاد اشیاء پیچیده با ترکیب **قطعات مختلف**.

#### نکات مثبت این دیزاین پترن:

+ افزایش **خوانایی و انعطاف‌پذیری** در ساخت اشیاء.
+ امکان **استفاده مجدد** از کد ساخت برای اشیاء مختلف.
+ **جداسازی کد ساخت** از منطق کسب‌وکار.

#### نکات منفی این دیزاین پترن:

+ **پیاده‌سازی پیچیده‌تر** نسبت به روش‌های ساده‌تر ایجاد اشیاء.
+ افزودن کلاس‌های سازنده می‌تواند **کد را حجیم‌تر** کند.

---

### الگوی تک‌نمونه (Singleton Pattern)

الگوی **تک‌نمونه** تضمین می‌کند که تنها **یک نمونه** از یک کلاس وجود داشته باشد و یک **نقطه دسترسی جهانی** به آن را فراهم می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ مدیریت **منابع مشترک** مانند اتصالات پایگاه داده یا تنظیمات سیستم.
+ پیاده‌سازی **رجیستری‌ها** یا **مدیران منابع**.
+ زمانی که نیاز به **کنترل مرکزی** بر روی یک شیء هست.

#### نکات مثبت این دیزاین پترن:

+ جلوگیری از ایجاد **چندین نمونه غیرضروری**، صرفه‌جویی در منابع.
+ فراهم کردن **دسترسی جهانی** به شیء.
+ **کنترل متمرکز** بر روی شیء.

#### نکات منفی این دیزاین پترن:

+ نقض **اصل مسئولیت واحد (SRP)**.
+ مشکلات در **تست واحد** و ایجاد وابستگی‌های پنهان.
+ ممکن است در **محیط‌های چند‌رشته‌ای** پیاده‌سازی پیچیده‌ای داشته باشد.

---

### الگوی نمونه‌برداری (Prototype Pattern)

الگوی **نمونه‌برداری** به شما اجازه می‌دهد تا اشیاء جدید را با **کپی کردن یک نمونه اولیه** (پروتوتایپ) ایجاد کنید. این روش برای زمانی که ایجاد اشیاء مستلزم هزینه یا زمان زیادی است مفید است.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که **ایجاد اشیاء جدید هزینه‌بر یا زمان‌بر** است و کپی کردن آن‌ها آسان‌تر است.
+ برای جلوگیری از ایجاد سلسله‌مراتب **کلاس‌های اضافی**.
+ زمانی که می‌خواهید **تغییرات جزئی** در نمونه‌های موجود ایجاد کنید.

#### نکات مثبت این دیزاین پترن:

+ **بهبود عملکرد** با کاهش هزینه ایجاد اشیاء.
+ تسهیل در ایجاد اشیائی با **مقادیر اولیه سفارشی**.
+ امکان **افزودن یا تغییر اشیاء در زمان اجرا**.

#### نکات منفی این دیزاین پترن:

+ **پیچیدگی در پیاده‌سازی** کپی عمیق و سطحی.
+ ممکن است پیگیری **تغییرات در نمونه‌ها** دشوار باشد.

---

## الگوهای ساختاری(Structural Pattern) 

### الگوی آداپتور (Adapter Pattern)

الگوی **آداپتور** به شما اجازه می‌دهد تا رابط یک کلاس موجود را به یک رابط دیگر تبدیل کنید که مشتریان انتظار دارند. این الگو به کلاس‌هایی که سازگار نیستند امکان همکاری با یکدیگر را می‌دهد.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که می‌خواهید از یک کلاس موجود استفاده کنید اما رابط آن با نیازهای شما مطابقت ندارد.
+ ترکیب دو کلاس ناسازگار بدون تغییر کدهای آن‌ها.
+ پیاده‌سازی سیستم‌های قدیمی با رابط‌های جدید.

#### نکات مثبت این دیزاین پترن:

+ **افزایش قابلیت استفاده مجدد** از کدهای موجود.
+ **انعطاف‌پذیری** در ارتباط بین سیستم‌ها یا کلاس‌های ناسازگار.
+ **سادگی در پیاده‌سازی** بدون نیاز به تغییر کدهای اصلی.

#### نکات منفی این دیزاین پترن:

+ می‌تواند **پیچیدگی را افزایش** دهد با افزودن لایه‌های اضافی.
+ ممکن است عملکرد را **کاهش** دهد به دلیل استفاده از واسط‌ها.
+ اگر بیش از حد استفاده شود، ممکن است **نگهداری کد** دشوار شود.

---

### الگوی پل (Bridge Pattern)

الگوی **پل** جداسازی بین انتزاع و پیاده‌سازی را فراهم می‌کند، به طوری که هر دو می‌توانند به طور مستقل تغییر کنند. این الگو از ترکیب ترجیحی به ارث‌بری استفاده می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که می‌خواهید **جداسازی کامل** بین انتزاع و پیاده‌سازی داشته باشید.
+ جلوگیری از **انفجار تعداد کلاس‌ها** در سلسله مراتب ارث‌بری.
+ وقتی که پیاده‌سازی **می‌تواند تغییر کند** بدون تأثیر بر مشتریان.

#### نکات مثبت این دیزاین پترن:

+ **افزایش انعطاف‌پذیری** در توسعه و نگهداری.
+ **تسهیل در افزودن** پیاده‌سازی‌ها یا انتزاعات جدید.
+ **کاهش اتصال** بین انتزاع و پیاده‌سازی.

#### نکات منفی این دیزاین پترن:

+ **پیچیدگی بیشتر** در ساختار کد و درک آن.
+ **افزایش تعداد کلاس‌ها** و نیاز به مدیریت آن‌ها.
+ ممکن است پیاده‌سازی آن **بیش از حد** برای پروژه‌های کوچک باشد.

---

### الگوی ترکیب (Composite Pattern)

الگوی **ترکیب** به شما اجازه می‌دهد تا اشیاء را به صورت ساختار درختی سازماندهی کنید، به طوری که با اشیاء منفرد و ترکیبی به صورت یکسان رفتار کنید.

#### موارد استفاده از این دیزاین پترن:

+ نمایش **ساختارهای سلسله مراتبی** مانند فایل سیستم‌ها.
+ زمانی که می‌خواهید عملیات یکسانی را بر روی اشیاء منفرد و ترکیبی اعمال کنید.
+ مدیریت مجموعه‌ای از اشیاء که ساختار درختی دارند.

#### نکات مثبت این دیزاین پترن:

+ **سادگی در استفاده**: کلاینت می‌تواند با تمامی اشیاء به صورت یکسان رفتار کند.
+ **افزایش انعطاف‌پذیری** در افزودن اجزاء جدید به ساختار.
+ **کاهش پیچیدگی کلاینت** با استفاده از رابط‌های مشترک.

#### نکات منفی این دیزاین پترن:

+ ممکن است **پیاده‌سازی پیچیده** شود، به ویژه برای ساختارهای بزرگ.
+ امکان **سوء استفاده** و ایجاد ساختارهای ناکارآمد.
+ دشواری در **اعمال محدودیت‌ها** بر روی اجزاء خاص.

---

### الگوی دکوراتور (Decorator Pattern)

الگوی **دکوراتور** به شما اجازه می‌دهد تا رفتارهای جدید را به اشیاء **به صورت دینامیک** اضافه کنید، بدون تغییر در کلاس‌های اصلی. این الگو اشیاء را درون اشیاء دکوراتور قرار می‌دهد.

#### موارد استفاده از این دیزاین پترن:

+ افزودن **قابلیت‌های اضافی** به اشیاء در زمان اجرا.
+ جایگزینی مناسب برای **ارث‌بری** جهت افزودن عملکرد.
+ زمانی که **زیرکلاس‌سازی** منجر به ایجاد تعداد زیادی کلاس می‌شود.

#### نکات مثبت این دیزاین پترن:

+ **افزایش انعطاف‌پذیری** در افزودن یا حذف رفتارها.
+ **ترکیب رفتارها** به صورت دلخواه.
+ **پیروی از اصل باز/بسته** (باز برای توسعه، بسته برای تغییر).

#### نکات منفی این دیزاین پترن:

+ می‌تواند منجر به **پیچیدگی در اشکال‌زدایی** شود.
+ **افزایش تعداد اشیاء** در حافظه.
+ امکان **سوء استفاده** و ایجاد زنجیره‌های دکوراتور طولانی.

---

### الگوی فاساد (Facade Pattern)

الگوی **فاساد** یک **رابط ساده و یکپارچه** برای یک سیستم پیچیده یا مجموعه‌ای از زیرسیستم‌ها فراهم می‌کند. این الگو پیچیدگی سیستم را از کلاینت‌ها پنهان می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ ساده‌سازی **رابط کاربری** با سیستم‌های پیچیده.
+ **کاهش وابستگی‌های** کلاینت به زیرسیستم‌های داخلی.
+ ایجاد نقطه ورودی **یکپارچه** به سیستم.

#### نکات مثبت این دیزاین پترن:

+ **ساده‌سازی استفاده** از سیستم توسط کلاینت‌ها.
+ **کاهش اتصال** بین سیستم و کلاینت‌ها.
+ امکان **کنترل و هماهنگی** زیرسیستم‌ها در یک نقطه.

#### نکات منفی این دیزاین پترن:

+ ممکن است تمامی **قابلیت‌های زیرسیستم‌ها** را ارائه ندهد.
+ ایجاد **نقطه شکست واحد** در صورت خرابی فاساد.
+ ممکن است **پنهان کردن پیچیدگی** منجر به مشکلاتی در آینده شود.

---

### الگوی فلای‌ویت (Flyweight Pattern)

الگوی **فلای‌ویت** به شما اجازه می‌دهد تعداد زیادی از اشیاء ریزدانه را با به اشتراک‌گذاری داده‌های مشترک بهینه کنید. این الگو از حافظه کمتری استفاده می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ مدیریت **تعداد زیادی اشیاء مشابه** که می‌توانند داده‌هایشان را به اشتراک بگذارند.
+ بهینه‌سازی **مصرف حافظه** در برنامه‌های گرافیکی یا بازی‌ها.
+ زمانی که **اشیاء تکراری** زیادی دارید و حافظه محدود است.

#### نکات مثبت این دیزاین پترن:

+ **کاهش مصرف حافظه** با به اشتراک‌گذاری داده‌ها.
+ **بهبود عملکرد** برنامه در منابع محدود.
+ **ساده‌سازی مدیریت اشیاء** با استفاده از اشتراک داده‌ها.

#### نکات منفی این دیزاین پترن:

+ **پیچیدگی در پیاده‌سازی** و مدیریت وضعیت اشیاء.
+ امکان **کاهش خوانایی کد** به دلیل استفاده از اشتراک‌گذاری.
+ **محدودیت در انعطاف‌پذیری**، زیرا برخی داده‌ها باید ثابت باشند.

---

### الگوی پروکسی (Proxy Pattern)

الگوی **پروکسی** یک **جایگزین یا نماینده** برای شیء اصلی فراهم می‌کند تا دسترسی به آن را کنترل کند. پروکسی عملکرد شیء اصلی را فراهم می‌کند و می‌تواند افزودنی‌هایی انجام دهد.

#### موارد استفاده از این دیزاین پترن:

+ **کنترل دسترسی** به منابع با ارزش یا حساس.
+ **افزودن عملکرد اضافی** مانند کش، لاگ‌گیری یا اعتبارسنجی.
+ مدیریت اشیاء **گران‌قیمت یا سنگین** که ایجاد آن‌ها هزینه‌بر است.

#### نکات مثبت این دیزاین پترن:

+ **کنترل بهتر** بر دسترسی و مدیریت شیء اصلی.
+ امکان **تأخیر در بارگذاری** یا **ایجاد اشیاء** به تعویق انداخته شده.
+ **افزایش امنیت** و **کاهش بار سیستم**.

#### نکات منفی این دیزاین پترن:

+ **افزایش پیچیدگی** در ساختار کد.
+ ممکن است به **عملکرد آسیب بزند** به دلیل لایه اضافی.
+ نیاز به **هماهنگی دقیق** بین پروکسی و شیء اصلی.

---

## الگوهای رفتاری(Behavioral Pattern) 
البته، با کمال میل تمام الگوهای رفتاری را طبق قالب مورد نظر شما ارائه می‌دهم.

---

### الگوی زنجیره مسئولیت (Chain of Responsibility Pattern)

الگوی **زنجیره مسئولیت** به شما اجازه می‌دهد که یک درخواست را از طریق زنجیره‌ای از اشیاء ارسال کنید تا زمانی که یکی از آن‌ها به درخواست پاسخ دهد، بدون اینکه فرستنده نیاز به دانستن گیرنده دقیق داشته باشد.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که **بیش از یک شیء** می‌تواند به یک درخواست پاسخ دهد و نمی‌خواهید فرستنده مشخص کند کدام شیء.
+ پیاده‌سازی **فیلترها یا پردازش‌های سلسله‌مراتبی**، مانند **سیستم‌های پشتیبانی مشتری**.
+ مدیریت **مجوزها و احراز هویت** در سیستم‌ها.

#### نکات مثبت این دیزاین پترن:

+ **کاهش اتصال بین فرستنده و گیرنده**: انعطاف‌پذیری در تغییر زنجیره بدون تأثیر بر فرستنده.
+ **افزودن یا حذف آسان هندلرها**: با تغییر زنجیره مسئولیت.
+ **استفاده مجدد از کد**: هندلرها می‌توانند در زنجیره‌های مختلف استفاده شوند.

#### نکات منفی این دیزاین پترن:

+ **عدم تضمین رسیدگی به درخواست**: ممکن است هیچ هندلری درخواست را پردازش نکند.
+ **اشکال‌زدایی دشوار**: دنبال کردن جریان درخواست در زنجیره ممکن است پیچیده باشد.
+ **کاهش کارایی**: اگر زنجیره طولانی باشد، زمان پردازش افزایش می‌یابد.

---

### الگوی فرمان (Command Pattern)

الگوی **فرمان** یک درخواست را به عنوان یک شیء کپسوله می‌کند، که به شما اجازه می‌دهد عملیات را پارامتریک کنید، صف‌بندی کنید، یا عملیات undo/redo را پیاده‌سازی کنید.

#### موارد استفاده از این دیزاین پترن:

+ **پیاده‌سازی undo/redo** در نرم‌افزارهایی مانند **ویرایشگرهای متن**.
+ **صف‌بندی درخواست‌ها** و اجرای آن‌ها در زمان‌های مختلف.
+ **پیاده‌سازی ماکروها**: ترکیب چند فرمان به یک فرمان واحد.
+ **کنترل منوها و دکمه‌ها** در رابط‌های کاربری.

#### نکات مثبت این دیزاین پترن:

+ **جداسازی درخواست از گیرنده**: انعطاف‌پذیری در تغییر یا تعویض گیرنده‌ها.
+ **افزودن فرمان‌های جدید** به سادگی با ایجاد کلاس جدید.
+ **پیاده‌سازی آسان undo/redo** با ذخیره تاریخچه فرمان‌ها.

#### نکات منفی این دیزاین پترن:

+ **افزایش تعداد کلاس‌ها**: هر فرمان نیاز به یک کلاس جداگانه دارد.
+ **پیچیدگی در مدیریت حالت‌ها**: به‌ویژه برای undo/redo.
+ **منابع اضافی**: ذخیره‌سازی تاریخچه فرمان‌ها مصرف منابع را افزایش می‌دهد.

---

### الگوی مفسر (Interpreter Pattern)

الگوی **مفسر** یک راه برای ارزیابی جملات گرامری در یک زبان خاص دامنه (DSL) فراهم می‌کند. این الگو زبان را به سلسله مراتب کلاس‌ها تبدیل می‌کند که هر کدام یک قانون گرامری را نمایش می‌دهند.

#### موارد استفاده از این دیزاین پترن:

+ **پیاده‌سازی زبان‌های سفارشی** برای کاربردهای خاص، مانند **زبان‌های اسکریپت‌نویسی**.
+ **تفسیر دستورات** در نرم‌افزارهایی مانند **ماشین‌حساب‌ها** یا **سیستم‌های خبره**.
+ **تحلیل و ارزیابی** عبارات ریاضی یا منطقی.

#### نکات مثبت این دیزاین پترن:

+ **تسهیل در افزودن قوانین جدید**: با افزودن کلاس‌های جدید.
+ **ساختاردهی روشن کد**: هر قانون گرامری کلاس خاص خود را دارد.
+ **قابلیت توسعه بالا**: مناسب برای زبان‌های ساده و قابل گسترش.

#### نکات منفی این دیزاین پترن:

+ **کارایی پایین**: برای زبان‌های پیچیده مناسب نیست.
+ **افزایش تعداد کلاس‌ها**: هر قانون نیاز به یک کلاس دارد.
+ **نگهداری دشوار**: پیچیدگی در مدیریت تعداد زیادی از کلاس‌های گرامری.

---

### الگوی تکرارگر (Iterator Pattern)

الگوی **تکرارگر** یک روش استاندارد برای دسترسی به عناصر یک مجموعه بدون افشای ساختار داخلی آن فراهم می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ پیمایش **ساختارهای داده‌ای پیچیده** مانند **لیست‌ها، درخت‌ها، گراف‌ها**.
+ فراهم کردن **رابط یکنواخت** برای انواع مختلف مجموعه‌ها.
+ پیاده‌سازی **عملیات پیمایشی** سفارشی.

#### نکات مثبت این دیزاین پترن:

+ **جداسازی پیمایش از ساختار داده**: امکان تغییر ساختار بدون تأثیر بر کد پیمایش.
+ **انعطاف‌پذیری بالا**: امکان تعریف تکرارگرهای مختلف برای یک مجموعه.
+ **ساده‌سازی کد کلاینت**: دسترسی آسان به عناصر بدون دانستن جزئیات پیاده‌سازی.

#### نکات منفی این دیزاین پترن:

+ **پیچیدگی در پیاده‌سازی** برای ساختارهای داده‌ای خاص.
+ **احتمال مشکلات همزمانی**: در صورت تغییر مجموعه در حین پیمایش.
+ **افزایش کلاس‌ها**: نیاز به ایجاد کلاس یا رابط تکرارگر.

---

### الگوی میانجی (Mediator Pattern)

الگوی **میانجی** ارتباطات پیچیده بین اشیاء را با معرفی یک شیء میانجی ساده می‌کند، که مسئولیت مدیریت و هماهنگی تعاملات را بر عهده دارد.

#### موارد استفاده از این دیزاین پترن:

+ **کاهش وابستگی متقابل** بین اشیاء در یک سیستم پیچیده.
+ مدیریت **رابط‌های کاربری پیچیده**، مانند **گفتگوهای چندکنترلی**.
+ هماهنگی **اجزای مختلف سیستم** بدون نیاز به ارتباط مستقیم.

#### نکات مثبت این دیزاین پترن:

+ **کاهش اتصال بین اشیاء**: اشیاء فقط با میانجی در تعامل هستند.
+ **ساده‌سازی ارتباطات**: میانجی منطق تعاملات را مدیریت می‌کند.
+ **تسهیل در نگهداری و توسعه**: تغییرات در یک شیء نیازی به تغییر در اشیاء دیگر ندارد.

#### نکات منفی این دیزاین پترن:

+ **افزایش پیچیدگی میانجی**: ممکن است به یک کلاس بزرگ و پیچیده تبدیل شود.
+ **نقض اصل مسئولیت واحد**: میانجی ممکن است وظایف متعددی بر عهده بگیرد.
+ **کاهش شفافیت**: دشواری در درک جریان تعاملات.

---

### الگوی یادگاری (Memento Pattern)

الگوی **یادگاری** وضعیت داخلی یک شیء را بدون نقض کپسوله‌سازی ذخیره و بازیابی می‌کند، که امکان بازگشت به حالت‌های قبلی را فراهم می‌سازد.

#### موارد استفاده از این دیزاین پترن:

+ **پیاده‌سازی undo/redo** در نرم‌افزارهای **ویرایشگر متن** یا **طراحی گرافیکی**.
+ **ذخیره‌سازی حالت‌های تاریخی** در **بازی‌های ویدئویی**.
+ **بازیابی اطلاعات** در صورت بروز خطا یا خرابی سیستم.

#### نکات مثبت این دیزاین پترن:

+ **حفظ کپسوله‌سازی**: وضعیت داخلی شیء برای دیگران مخفی می‌ماند.
+ **سهولت در بازگردانی حالت**: امکان بازگشت به حالت‌های قبلی به سادگی.
+ **بهبود تجربه کاربری**: فراهم کردن امکان لغو تغییرات.

#### نکات منفی این دیزاین پترن:

+ **مصرف حافظه بالا**: ذخیره‌سازی وضعیت‌های متعدد ممکن است منابع زیادی مصرف کند.
+ **پیچیدگی مدیریت یادگاری‌ها**: نیاز به استراتژی برای حذف یا مدیریت یادگاری‌های قدیمی.
+ **امنیت داده‌ها**: نیاز به حفاظت از یادگاری‌های ذخیره‌شده.

---

### الگوی ناظر (Observer Pattern)

الگوی **ناظر** یک مکانیزم انتشار/اشتراک فراهم می‌کند که در آن یک شیء (Subject) تغییرات خود را به مجموعه‌ای از ناظرین (Observers) اعلام می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ **به‌روزرسانی خودکار اجزای رابط کاربری** در پاسخ به تغییرات داده.
+ **سیستم‌های رویداد محور**، مانند **مدیریت رویدادهای کاربر**.
+ انتشار تغییرات در **سیستم‌های توزیع‌شده**.

#### نکات مثبت این دیزاین پترن:

+ **کاهش اتصال بین اشیاء**: ناظرین نیاز به دانستن جزئیات Subject ندارند.
+ **افزودن آسان ناظرین جدید**: بدون تغییر در Subject.
+ **انعطاف‌پذیری در توزیع رویدادها**: مدیریت ارتباطات چندبه‌چند.

#### نکات منفی این دیزاین پترن:

+ **پیچیدگی در اشکال‌زدایی**: ردیابی اطلاع‌رسانی‌ها ممکن است سخت باشد.
+ **خطر نشت حافظه**: اگر ناظرین به درستی مدیریت نشوند.
+ **عدم تضمین ترتیب اطلاع‌رسانی**: ممکن است ترتیب به‌روزرسانی‌ها مهم باشد.

---

### الگوی وضعیت (State Pattern)

الگوی **وضعیت** به یک شیء اجازه می‌دهد تا رفتار خود را زمانی که حالت داخلی‌اش تغییر می‌کند، تغییر داده و به نظر برسد که کلاس شیء تغییر کرده است.

#### موارد استفاده از این دیزاین پترن:

+ پیاده‌سازی **ماشین‌های حالت** در **بازی‌های ویدئویی** یا **اتوماسیون صنعتی**.
+ زمانی که رفتار یک شیء بستگی به **حالت داخلی** آن دارد و باید **در زمان اجرا تغییر کند**.
+ جایگزینی **دستورالعمل‌های شرطی پیچیده** (if-else یا switch-case) با ساختارهای قابل نگهداری‌تر.
+ مدیریت **مراحل مختلف یک فرآیند**، مانند **چرخه حیات یک سفارش آنلاین**.

#### نکات مثبت این دیزاین پترن:

+ **سازماندهی بهتر کد**: جداسازی منطق هر حالت در کلاس‌های جداگانه.
+ **افزایش قابلیت نگهداری**: افزودن حالت‌های جدید بدون تغییر در کدهای موجود.
+ **کاهش پیچیدگی**: حذف دستورالعمل‌های شرطی پیچیده.
+ **افزایش قابلیت تست**: تست مستقل هر حالت.

#### نکات منفی این دیزاین پترن:

+ **افزایش تعداد کلاس‌ها**: هر حالت یک کلاس جداگانه است.
+ **پیچیدگی در مدیریت انتقال بین حالت‌ها**: نیاز به تعریف واضح انتقال‌ها.
+ **ممکن است برای سیستم‌های ساده بیش از حد باشد**.
+ **نیاز به هماهنگی بین حالت‌ها**: احتمال تداخل رفتارها.

---

### الگوی استراتژی (Strategy Pattern)

الگوی **استراتژی** به شما اجازه می‌دهد تا الگوریتم‌های مختلف را کپسوله کرده و در زمان اجرا آن‌ها را تعویض کنید. این الگو رفتار یک شیء را بدون تغییر در کدهای اصلی، با تغییر استراتژی مورد استفاده، منعطف می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که چندین الگوریتم مشابه وجود دارد و می‌خواهید بین آن‌ها **سوئیچ** کنید، مانند **مرتب‌سازی بر اساس معیارهای مختلف**.
+ برای جداسازی **کد انتخاب الگوریتم** از کد اصلی، به منظور **ساده‌سازی نگهداری**.
+ در مواردی که نیاز به افزودن الگوریتم‌های جدید بدون تغییر در کدهای موجود است.
+ **پیاده‌سازی سیستم‌های قابل توسعه** مانند **پردازش متن** با فرمت‌های مختلف.

#### نکات مثبت این دیزاین پترن:

+ **افزایش انعطاف‌پذیری**: امکان تغییر رفتار برنامه در زمان اجرا.
+ **پیروی از اصل مسئولیت واحد (SRP)**: هر استراتژی مسئول یک الگوریتم خاص است.
+ **ساده‌سازی تست**: می‌توان هر الگوریتم را به صورت مستقل تست کرد.
+ **کاهش وابستگی**: کد اصلی به جزئیات الگوریتم‌ها وابسته نیست.

#### نکات منفی این دیزاین پترن:

+ **افزایش تعداد کلاس‌ها**: هر استراتژی یک کلاس جداگانه است.
+ **پیچیدگی در مدیریت استراتژی‌ها**: نیاز به درک تفاوت‌ها و انتخاب صحیح.
+ **نیاز به هماهنگی**: ممکن است استراتژی‌های ناسازگار استفاده شوند.

---

### الگوی روش قالب (Template Method Pattern)

الگوی **روش قالب** یک اسکلت برای یک الگوریتم در یک متد تعریف می‌کند، در حالی که پیاده‌سازی مراحل خاص را به زیرکلاس‌ها واگذار می‌کند.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که چندین کلاس **ساختار الگوریتم مشابهی** دارند، اما جزئیات متفاوت است.
+ برای جلوگیری از **تکرار کد** با استخراج بخش‌های مشترک.
+ پیاده‌سازی **چارچوب‌های نرم‌افزاری** که بخش‌هایی قابل گسترش دارند.

#### نکات مثبت این دیزاین پترن:

+ **استفاده مجدد از کد**: استخراج منطق مشترک در کلاس پایه.
+ **ساده‌سازی توسعه**: تمرکز بر جزئیات خاص در زیرکلاس‌ها.
+ **کنترل بر ساختار الگوریتم**: اطمینان از پیروی زیرکلاس‌ها از الگوی مشخص.

#### نکات منفی این دیزاین پترن:

+ **محدودیت انعطاف‌پذیری**: زیرکلاس‌ها باید ساختار تعریف‌شده را رعایت کنند.
+ **وابستگی به کلاس پایه**: تغییر در کلاس پایه ممکن است تأثیر گسترده‌ای داشته باشد.
+ **افزایش پیچیدگی**: در صورت وجود سلسله مراتب پیچیده از کلاس‌ها.

---

### الگوی بازدیدکننده (Visitor Pattern)

الگوی **بازدیدکننده** به شما اجازه می‌دهد تا عملیات جدیدی را بدون تغییر در کلاس‌های عناصر به آن‌ها اضافه کنید، با جداسازی الگوریتم از ساختار داده.

#### موارد استفاده از این دیزاین پترن:

+ زمانی که می‌خواهید **عملیات جدیدی** بر روی عناصر یک ساختار شیءگرا انجام دهید.
+ **پیاده‌سازی عملیات‌های متنوع** بر روی **ساختارهای داده‌ای پیچیده**، مانند **درخت‌ها**.
+ جداسازی **رفتارهای متغیر** از **ساختارهای پایدار**.

#### نکات مثبت این دیزاین پترن:

+ **افزودن آسان عملیات جدید**: بدون تغییر در کلاس‌های عناصر.
+ **پیروی از اصل تک‌مسئولیتی**: جداسازی عملیات از ساختار داده.
+ **تسهیل در نگهداری و توسعه**: تغییرات در بازدیدکننده‌ها تأثیری بر عناصر ندارد.

#### نکات منفی این دیزاین پترن:

+ **افزودن عناصر جدید دشوار**: نیاز به تغییر در تمامی بازدیدکننده‌ها.
+ **پیچیدگی در درک و پیاده‌سازی**: به‌ویژه برای تازه‌کاران.
+ **تداخل با کپسوله‌سازی**: بازدیدکننده ممکن است نیاز به دسترسی به جزئیات عناصر داشته باشد.


</div>